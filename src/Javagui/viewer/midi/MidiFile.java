/*
---- 
This file is part of SECONDO.

Copyright (C) 2004, University in Hagen, Department of Computer Science, 
Database Systems for New Applications.

SECONDO is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

SECONDO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with SECONDO; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
----

//paragraph    [1]     Title:         [{\Large \bf \begin {center}]        [\end {center}}]
//paragraph    [21]    table1column:  [\begin{quote}\begin{tabular}{l}]    [\end{tabular}\end{quote}]
//paragraph    [22]    table2columns: [\begin{quote}\begin{tabular}{ll}]   [\end{tabular}\end{quote}]
//paragraph    [23]    table3columns: [\begin{quote}\begin{tabular}{lll}]  [\end{tabular}\end{quote}]
//paragraph    [24]    table4columns: [\begin{quote}\begin{tabular}{llll}] [\end{tabular}\end{quote}]
//[--------]    [\hline]
//characters [1] verbatim:   [$]    [$]
//characters [2] formula:    [$]    [$]
//characters [3] capital:    [\textsc{]    [}]
//characters [4] teletype:   [\texttt{]    [}]
//[ss] [{\ss}]
//[<=] [\leq]
//[#]  [\neq]
//[tilde] [\verb|~|]
//[->] [$\rightarrow $]

\pagebreak

1 Implementation of MidiFile

This class provides a design to represent Midi objects in java. As the
MidiViewer handles only one sequencer, the current implementation of
MidiFile is some sort of a ~lightweight~ object design. In fact, only the
sequence and some (generated) meta informations are part of a
MidiFile object.


2 Imports

*/

package viewer.midi;

import javax.swing.*;
import javax.swing.filechooser.*;
import gui.SecondoObject;
import sj.lang.*;
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.*;
import javax.sound.midi.*;
import javax.sound.midi.Track.*;
import java.util.Vector;
import tools.Reporter;

/*
2 Class ~MidiFile~

*/


public class MidiFile
{
/*
2.1 private Components of a MidiFile

The main content of this object is the sequence, containing all
informations of an Midi file

*/
  private Sequence sequence = null;

/*
A MidiFile has actually two names. The first one is the name it gets
from SECONDO itself. This name is a copy of its own query call. The
assumedName is generated from the Midi sequence itself, evaluating
its metamessages. Unfortunately there is no adequate standard for these
metamessage (in matters of name descriptions) as there is no special
metaevent for this purpose. So it is not possible to get the right
name surely. That's why the name is ~assumed~.

*/
  private String name        = "No Name declared... NOW!";
  private String assumedName = "No Name found";

/*
The SECONDO-ID

*/
  private String id;

/*
Trackhandling variables

*/
  private Track[] tracks;
  private int numberOfTracks = 0;
  private int expectedTracks;
  private MidiTrack[] mTracks;

/*
2.1 Constructor

The constructor is called with three arguments. First, an inputstream
representing the binary input of a Midi. Second, the name of the object
in Secondo terms (e.g. query midi1). Third, the constructor gets the
SECONDO-ID of the Midi file.

*/


public MidiFile (InputStream stream, String secondoName, String secondoID)
{
  name = secondoName;
  id   = secondoID;

  try {sequence = MidiSystem.getSequence(stream);}
  catch (InvalidMidiDataException e)
  {
    Reporter.writeError("MidiFile 1: Invalid Midifile");
    name = "Error2";
  }
  catch (IOException e)
  {
     Reporter.writeError("MidiFile 2: Readingerror");
     name = "Error 2";
  }

/*
Analyzing the Tracks, to find all usefull meta informations

*/

  tracks            = sequence.getTracks();
  numberOfTracks    = tracks.length;
  mTracks           = new MidiTrack[tracks.length];
  boolean foundName = false;

  for (int t =0; t < tracks.length; t++)
  {
    mTracks[t] = new MidiTrack(t, tracks[t]);

    if (mTracks[t].foundPossibleName() && !foundName)
    {
      foundName   = true;
      assumedName = mTracks[t].getName().substring(3);
    }
  }
}

/*
2.1 get-Methods

2.1.1 getName

Returns the assumed name, generated by the meta informations provided
by the sequence itself

*/


public String getName()
{
  return assumedName;
}


/*
2.1.1 getID

Returns the Secondo ID of this Object

*/
public String getID()
{
  return id;
}

/*
2.1.1 getSequence

Returns the main information of a MidiFile, the sequence itself.
It's expecially needed by the viewer to load the sequence into the
sequencer.

*/
public Sequence getSequence()
{
  return sequence;
}

/*
2.1.1 getNrTracks

Returns the number of tracks of the MidiFile

*/

public int getNrTracks()
{
  return numberOfTracks;
}

/*
2.1.1 getResolution

Returns the Resolution of a sequence. The analysis of what kind
of divisiontype is currently used belongs to the viewer. It checks if it is
PPQ (ticks per beat) or SMTPE (ticks per Frame).

*/

public int getRes()
{
  return sequence.getResolution();
}

/*
2.1.1 getTrackArray

Returns the array containing the tracks of the sequence

*/
public MidiTrack[] getTrackArray()
{
  return mTracks;
}

/*
2.1.1 getMetaInfos

Returns a vector of the meta informations generated by the constructor

*/

public Vector getMetaInfos(int trackNo)
{
  try
  {
    return mTracks[trackNo].getMeta();
  }
  catch (ArrayIndexOutOfBoundsException e)
  {
    return null;
  }
}

/*
2.1.1 getDivisionType

Returns the divisiontype of the sequence

*/

public float getDivisionType()
{
  return sequence.getDivisionType();
}


/*
2.1 additional Methods

2.1.1 equals

Checks if the MidiFile was generated from the Secondo-Object with
this ID

*/

public boolean equals(String secondoID)
{
  return (id == secondoID);
}



/*
2.1.1 export

Provides a simple and easy way to save the running Midi.
Expecially, when midis are displayed out of a relation the
operator ~saveto~, would not be ones first choice.

*/

public void export()
{
  final JFileChooser fc = new JFileChooser();
  fc.addChoosableFileFilter(new MidiFilter());

  int  returnVal  = fc.showSaveDialog(null);
  File chosenFile = fc.getSelectedFile();
  File file;

  if (returnVal == JFileChooser.APPROVE_OPTION)
  {
    try
    {
      String ex = MidiFilter.getExtension(chosenFile);
      if (ex == null || !(ex.equals("mid") || ex.equals("midi")))
      {
        file = new File(chosenFile.getAbsolutePath() + ".mid");
      }
      else
      {
        file = fc.getSelectedFile();
      }
      MidiSystem.write(sequence,1,file);
    }
    catch (Exception e) {Reporter.writeError("Error in writing");}
  }
}

/*
2.1.1 toString

Overrides the toString-Method. It is used to display the ~query~-name inside the playlist.

*/

public String toString()
{
  return name;
}

}
